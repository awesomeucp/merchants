import fs from 'fs';
import path from 'path';
import type {
  Merchant,
  DirectoryMetadata,
  CategoryCount,
  CapabilityCount,
  PaymentProviderCount
} from '@/lib/types/merchant';
import { injectLogoToken } from '@/lib/utils/logo';

const MERCHANTS_DIR = path.join(process.cwd(), 'data', 'merchants');

/**
 * Load all merchant data at build time
 * Used by: API routes, page generation, metadata aggregation
 */
export function getAllMerchants(): Merchant[] {
  if (!fs.existsSync(MERCHANTS_DIR)) {
    return [];
  }

  const files = fs.readdirSync(MERCHANTS_DIR)
    .filter(file => file.endsWith('.json'));

  const merchants = files.map(file => {
    const filePath = path.join(MERCHANTS_DIR, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const merchant = JSON.parse(content) as Merchant;

    // Inject token into logo URL at runtime
    merchant.logo.url = injectLogoToken(merchant.logo.url);

    return merchant;
  });

  // Sort: featured first, then alphabetically
  return merchants.sort((a, b) => {
    if (a.metadata.featured !== b.metadata.featured) {
      return a.metadata.featured ? -1 : 1;
    }
    return a.name.localeCompare(b.name);
  });
}

/**
 * Get single merchant by slug
 */
export function getMerchantBySlug(slug: string): Merchant | null {
  const merchants = getAllMerchants();
  return merchants.find(m => m.slug === slug) || null;
}

/**
 * Load pre-generated directory metadata
 * Generated by: bun run metadata:generate
 */
export function getDirectoryMetadata(): DirectoryMetadata {
  const metadataPath = path.join(process.cwd(), 'data', 'metadata.json');

  if (!fs.existsSync(metadataPath)) {
    console.warn('⚠️  metadata.json not found. Run: bun run metadata:generate');
    // Fallback to old behavior for development
    return generateMetadataFromMerchants();
  }

  const content = fs.readFileSync(metadataPath, 'utf-8');
  return JSON.parse(content) as DirectoryMetadata;
}

/**
 * Legacy function - kept for fallback when metadata.json doesn't exist
 * @private
 */
function generateMetadataFromMerchants(): DirectoryMetadata {
  const merchants = getAllMerchants();

  // Aggregate categories
  const categoryCounts = new Map<string, number>();
  merchants.forEach(m => {
    m.categories.forEach(cat => {
      categoryCounts.set(cat, (categoryCounts.get(cat) || 0) + 1);
    });
  });

  // Aggregate capabilities
  const capabilityCounts = new Map<string, number>();
  merchants.forEach(m => {
    m.ucpProfile.capabilities.forEach(cap => {
      capabilityCounts.set(cap.name, (capabilityCounts.get(cap.name) || 0) + 1);
    });
  });

  // Aggregate payment providers
  const providerCounts = new Map<string, number>();
  merchants.forEach(m => {
    m.ucpProfile.paymentHandlers.forEach(handler => {
      handler.providers.forEach(provider => {
        providerCounts.set(provider, (providerCounts.get(provider) || 0) + 1);
      });
    });
  });

  return {
    totalMerchants: merchants.length,
    categories: Array.from(categoryCounts.entries())
      .map(([name, count]): CategoryCount => ({ name, count }))
      .sort((a, b) => b.count - a.count),
    capabilities: Array.from(capabilityCounts.entries())
      .map(([name, count]): CapabilityCount => ({
        name,
        displayName: formatCapabilityName(name),
        count
      }))
      .sort((a, b) => b.count - a.count),
    paymentProviders: Array.from(providerCounts.entries())
      .map(([name, count]): PaymentProviderCount => ({ name, count }))
      .sort((a, b) => b.count - a.count),
  };
}

/**
 * Convert "dev.ucp.shopping.checkout" to "Checkout"
 */
function formatCapabilityName(name: string): string {
  const parts = name.split('.');
  const last = parts[parts.length - 1];
  // Handle snake_case and convert to Title Case
  return last
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}
